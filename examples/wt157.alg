begin
    comment LIBRARY 1;
    boolean B;
    real X;
    integer array A [+ 1 : .6e2];
    integer I, N;
    B := false;
    N := 1e+2 * .6;
    X := 0;
    comment   ;
    begin
	comment   ;
	own real array C0 [0 : 1];
	procedure P (A, B, C); value A;
	    integer A;
	    string B;
	    boolean array C;
	    begin
	       begin
	          C [(1)] := true or .8 > C0 [if true then 0 else 1];
	          C [ - ( - 2) ]:= false and .4 >= X + 500e-2;
	          C [.3e1]:= (.3 ^= (0)) and (if 1e1 ^= 1e4 then true else false);
	          if false then
	             P(A, "STRING", C)
	          else
	       end;
	       for I := 1 step 1 until 3 do
	       begin
	          if .3 <= 6 div 2 then
	             goto  OUT;
	          OUT :
	       end;
	    end;

	    real procedure A0L;
	         A0L :=
	             if X < X then
	                1e4
	             else
	                .6;
	    integer procedure II;
	      II := + 1 * (3 div (4)) - 1e2 + A0L;

	    begin
	       boolean array C [II + II div II / II : 1^II + 3];
	       C0 [ 0 ]:=
	          if B and (1) = (2) then
	             0
	          else
	             0;
	       P ( + 1)L : ( " " )M : (C);
	       I := - N - I * N div N^1;
	       goto
	          if 1 - .9 = II / 6 and II <= A0L then
	             L
	          else
	             L1;
	       L :
	       L1 :
	       for I := I step N until II do
	          ;

	       if + .3 + 1e2 = + (.3) then
	          B := not B equiv false
	       else
	          B := 1e1 > 3 equiv true;

	       for I := ((1)) step + (1) until + 60 do
	       begin
	           A [1e1 - 9] := 1 / .1 - 0.1;
	           A [ I    ] :=
	            if (true) or A [1]- 1 ^= A [1e1 - 9] * 1 implies false then
	                + 1
	            else
	                - 1
	       end;

	       for  I := 1,
	                 - 9 + A [1] step  - 9 + A [1] + 1 until  .6e1 do
	          N :=
	              if + A [1] + 0 = A [1] then
	                 0
	              else
	                 1e1 - 9 + N;
	       if + N ^= + 1 equiv N = - N or 0 < + N and 0 + N >= 0 then
	       else
	          goto L2;

	       B := B implies N > + 0 equiv 0 < - A [1] / 1e1 or true;
	   L2 :
	       goto (L3);
	   L3 :
	       B := true and false or false implies true equiv + 0 ^= - 1;
	       N := 1^N * 1 + (1e1) * 1e-2^(1) / (2) + N;
	       B := true equiv - (0) div 1 > - A [1] or not true equiv not true;
	       B := not false equiv .1 = 1 implies true implies 0 ^= 1;
	       for I := 1 while true do
	          goto EXIT;
	   EXIT :

	       for I := I while false do
	          if - 0 >= + 6 then
	             for N := 1 while 0 >= - 1 or + N <= + (1) do
	                 for N := 1 do
	                   ;
	       B := 0 < 1e1 implies + 1 <= .1 or - 3 <= - 6 and true and + 1 <= 1e1;
	       B := B implies - (1) < (2) equiv 1e1 = .1 and - (1) <= 0;
	       if C [1] implies not + 1 = 1e1 then
	          ;
	       X := A [1]^.5 ^1e1 + if (not N >= .1) or
	                      (if true then false else true) then -1 else +2;
	       begin
	          integer procedure A0 (B, C); boolean B, C;
	             A0 :=
	                if B implies not C then
	                    (1)^2
	                else
	                if C and not B then
	                    (1)
	                else
	                    (2);
	          X := X + A0 (true, false) + A0 (false, true implies .4 < .6);
	          N := X * A0 (not 0 = 1e1, 1 >= 1e2) - A0 (not - 1 > .1,
	                                                     not .1 <= (1))
	       end;

	       begin
	          goto L4;
	      L4 :
	          begin
	             for I := I step if 1 < 2 then 1 else 2 until - 10 do
	          end;
	          if
	            if B then
	                .1 > 1e1
	            else
	                not 1e1 ^= .6
	          then
	             begin
	                X := X + 100
	             end
	          else
	             for I := 1 step .3e1 until if not (false) then
	                                          1 else
	                                          A [1] do
	                B := true;
	       end;
	       B := false;
	    end;
	    begin
	       real Y;
	       array D [C0 [0]: + A [1] div 1 + 1 + C0 [0]];
	       boolean procedure B1;
	       begin
	          own boolean X;
	          X :=
	             if D [0] < 0 then
	                not  D [0] <= (0) implies (D [0] >= (1))
	             else
	                B;
	          B := X and 1e1 + D [0] > (1) equiv (D [0] ^= 0);
	          B1 := B or 1e1 + D [0] = D [0] equiv (1) > D [0]
	       end;
	       switch S := L10, L11;
	       D [0] := 0;
	       B := B1 implies 1e1 + (1) ^= D [0] and B;
	   L10 :;
	   L11 :;
	    end;

	   begin
	      switch SS := LA, LB;
	      own integer P;
	      procedure Q (L); label L;
	      begin
	          array R [(0) : - ( - 1)], S [1 : 1e1];
	          for I := 0,
	                   + 1,
	                   .3,
	                   1e1,
	                   (2),
	                   if B then 0 else 1 do begin end;
	          for I := 1 while I + (0) >= 9,
	                             I + 1 while + I < 10 do
	              S [I] := 0;

	          for I := 1 + S [2] while - I > 0,
	                   I + (1) while not I >= 10 do
	             if  B then
	      end;
	      Q(LA);
	   LA :;
	   LB :;
	   end;
	   begin
	      procedure P;
	      begin
	          ;
	         for I := 1 while if 1 < 2 then 0 = A [1] else (A [1]) > 0 do
	      end;
	      array D [1 : if 1 < 2 then 2 else 1];
	      for I := 1 while .1 < - 3,
	               I + 1 while (I) < 3 do
	         D [I]:= I;

	      for I := D [2],
	               1 step (1) until (1) do
	         if 1 < 2 then
	      L :
	         else
	            begin
	            end;

	      P;

	      for I := 1 step 1e1 - 9 until 1e1 - 9,
	               1 while 1e1 > 11 do
	         X := X + N
	   end;
	   outreal (1, X + N);
	end;
end;


